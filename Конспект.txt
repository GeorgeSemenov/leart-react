Полное видео тут: https://www.youtube.com/watch?v=GNrdg3PzpJQ&ab_channel=UlbiTV

Как реакт работает.
Реакт это не библиотека для вэб приложений, он может работать сам по себе
За отображанеие в браузере отвечает библиотека react dom

Приложение реакт это набор связанных компонентов.
В начале работы реакт создаёт "дерево реакт элементов"(более лёгкая чем dom дерево), которое потом трансформируется в dom дерево
Как только в реакт компонентах происходит изменения, до реакт создаёт другое дерево с изменёнными 
компонентами и сравнивает его с предыдущим деревом реакт элементов (там где узлы имеют старые значения). Эта стадия называется "Согласование"
Согласование происходит как в браузере так и в других средах, где будет запущен реакт.

После того, как различия были выявлены в результате согласования - происходит фаза рендеринга(отрисовки) (за эту фазу отвечает react dom, react native)
причём у отрисовки есть приоритетность, поэтому некоторые элементы отображаются быстрее.

В компоненте - классе когда в onClick указываешь стерлочную функцию то она сработает не так как
мы ожидаем, особенно, если ты не оперируешь переменными состояния.
Проще говоря, если рендеринг зависит от переменных, то они должны быть состояними, если ты просто
их укажешь как переменные или свойства объекта реакт, то сам реакт их не отрисует.

Когда вешаешь на тэг (input,button ...) событие - это событие может принимать в аргумент 
объект события (event) у этого объекта есть поле target - этот объект и есть node узел, где сработало это событие, уже у этого объекта можно взять value, className ...
Выглядит это так : onChange={(event)=>{setValue(event.target.value)}}

 Файлы компонентов нужно нахывать также как и сам компонент и ВСЕГДА  с большой буквы.
 
 Состояния компонентов - независимы.
 Т.е. если ты создашь элемент counter и вызовёшь его несколько раз, то значения всех counter'ов будут различны.

---Классовые компокнетнты (classCounter)
В реакт классах нельзя напрямую изменять состояния, т.к. реакт компонент НЕ УВИДИТ изменений.
Для измнения состояния в классах нужно использовать метод setState куда нужно будет вписывать изменённые поля state
например this.setState({count: this.state.count+1});
Также внутри класса нужно обрщаться к переменным и функциям через this
Также в классовых компонентах в методах - контекст теряется, поэтому в конструкторе нужно их бидить
Например так: constructor(props){super(props); this.someFunc = this.someFunc.bind(this)}
до30 минуты

---Массив хуков состояние 
Он записывается следующим образом :
const [posts,setposts] = useState([
	{},
	{},
	{},
])
Кстати, для преобразования массива данных в массив постов - используй .map , а не forEach, как ты это любишь делать
с map всё намного лучше читается {post.map(post=><Post post=post />))
---Как добавлять новые элементы в массив хуков состояния
setPosts([...posts,newPost])
	запись ...posts - означает что массив со старыми данными posts - является частью нового массива + ещё один новый элемет newPost
	Таким образом в setPosts передаётся новый массив который состоит из старого + новый элемент.

---Как перезатирать значения полей в объекте
Допустим у нас есть объект post, и нам нужно через setPost поменять поле title - всё просто
setPost({...post, title: "newTitle"}) - вначале даётся старый объект post, затем в нём перезатирается поле title

---ключи списков
key - лучше указывать не через index массива, а через отдельное свойство отведённое специально для этого.
post = {id = 1, desc = "some description" , title = "some title" } - видишь id? Вот его и нужно пихать в key
index - использовать нежелательно, т.к. index может измениться при удалении или смещении элементов, а ключ - всегда
должен быть постоянным.
Благодоря ключам - отрисовываться будут только те элементы списка, которые изменились, а не весь список.

*О*Управляемый компонент - это компонент формы, состояние которого изменяется под дейсвием пользователя (через react)
Ты можешь ввести название поста в инпут, а react уже изменит аттрибут value этого компонента(у input'а).

*О*Двустороннее связывание - это состояние компонента изменяют компоненти и когда компонент может сам изменять своё состояние
(посредством пользователя или чего-то ещё)

---инлайновые стили прописываются следующим образом
<h1 style = {{textAlign: "center"}}>Список задач</h1>

---Вместо props можно передавать конкретные переменные
const PostList = ({posts,title})=>{} - этот компонент принимает НЕ PROPS А POSTS. эта переменная сразу извлекается
из props, и дальше её можно использовать без указания props. Т.е. не props.posts а просто posts.
Если же прописать нужно выделить несколько аргументов и остально положить в props, то используют следующую запись
const Component = ({someArg1, someArg2, ... props}) {}. Теперь в props будет всё кроме someArg1 и someArg2

---Чтобы аттрибуты компонента попадали в сами тэги нужно это указать напрямую
<button {...props}> </button>
Это очень поможет при аттрибутах checked и disabled

---Модульное добавление стилей (42.минут. 30 секунда)
Ты можешь создать файл имяКомпонента.module.css
В нём указать селектор(класс) и свойства к нему, а затем, в нужный компонент
ты можешь это импортировать командой
import classes from './имяКомпонента.module.css'
и в нужно строке вызвать аргумент класса - <button className={classes.myBtn}>
смотри подробнее в src-components-UI-button-MyButton.jsx
Такой подход генерирует уникальные названия классов, что позволяет не прибегать к БЭМ.
Например, ты вызвал класс myBtn в компоненте MyButton, значит после сборки класс будет называться - MyButton_myBtn__B8hLn
Это приводит к изоляции стилей и БЭМ становится ненужным

---PROPS.CHILDREN
Данный пропс позволяет закрывающим тэгам получать информацию заключённую между ними. Т.е.
<MyButton> some button text </MyButton> 
Чтобы отобразить some button text - нужно использовать props.children


---Работа с кнопкой.
При нажатии на кнопку происходит обновление страницы? Всё дело в том, что когда ты добавляешь кнопку в форму у неё по умолчанию
type="submit", когда в браузере происходит submit формы - браузер по умолчанию обновляет стринцу и данные уходят на сервер.
Поэтому часто данное поведение предотвращают с помощью метода preventDefault у объекта event (обычно ты пишешь e)
Просто пишешь в функции обработчике события следующее :
const addNewPost = (e)=>{
    e.preventDefault();
    doSomeStuff()
  }

---Способы получения данных из input-ов
1)Создать управляемый элемент и с помощью onChange передавать данные 
2)Если input не управляемый то нужно использовать хук useRef() 50 минута и 55 секунда
	Этот хук позволяет получить доступ к dom элементу и уже у этого элемента получить value
	Для этого нужно у компонента указать props ref = {созданная useRef ссылка}
	У этой ссылки будет одно единственное поле .current - который в нашем случае и будет dom-элементом у которого можно взять value
	Но могут возникнут проблемы с кастомным элементом т.к. react не будет знать куда эту ссылку передать, 
	поэтому покажу пример вначале с просто тегом :
const bodyInputRef = useRef();
<input type="text" ref={bodyInputRef}/>
<MyButton 
  onClick = {(e)=>{e.preventDefault();console.log( );console.log(`bodyInputRef = ${bodyInputRef.current.value}`)}}
>Ужасающий текст занудного создания поста </MyButton>
	Обрати внимание , что если будет два inpu'a с атрибутом ref то в объекте bodyInputRef будут данные только о последнем, т.о.
	ты можешь получить данные только об одном input'е .
	Манипулировать dom деревом на прямую не рекомендуется.
Теперь что сделать, чтобы собственноручный элемент заработал как надо?
	Для этого нужно сам компонент обернуть в React.forwardRef, в таком случае помимо props, данный компонент
	сможет принимать и сам ссылку (ref)
const MyInput = React.forwardRef((props,ref)=>{...})

---Интересный способ создания и наполнения объекта
const title= "someTitle",
cons body = "someBody",
const newObj = {title,body}
Теперь в объекте newObj будут поля title = "someTitle" и body = "someBody"

---Как просто очистить управляемы input-ы
Просто после (допустим) нажатии кнопку добавить setTitle('')
Если в инпуте value = {title} то это значит, что теперь value = '' и input будет очищен

---Обмен данными между компонентами (потоки данных нисходящие и восходящие)
Передача через props от родителя к дочернему элементу. - нисходящий поток.
Когда родитель передаёт ребёнку колбэк, который позволяет изменять состояние родителя - восходящий поток.

---Условная отрисовка или отрисовка по условию
Это когда у тебя закончились все посты и тогда выходит надпись "Посты закончились"
Т.е. рендерятся элементы, при определённом условии
Как то так:
return (
	{
	  posts.length !=0 
	    ? <PostList/>    
	    : <p> Посты Закончились.</p>
	}
)

---На первый элемент section вешают disabled - так красивше
<select>
  <option disabled value={defaultValue}>Сортир овка по названию</option>
  {
    options.map(option=>
      <option value={option.value}>{option.name}</option>    
    )
  }
</select>

---Как обновлять состояние методами, которые не возвращают новый массив/объект, а изменяют уже имеющийся
---Как обновлять состояние методом массива sort
sort - не возвращает новый массив, он изменяет тот, к которому был применён, поэтому нельзя 
его просто передать в setPosts(posts.sort(...)), т.к. напрямую состояния изменять нельзя, реакт их не 
увидит. В таком случае нужно всего лишь ... без смс и регистрации.
Создаём копию массива [...posts], изменяем её и передаём в setPosts. Вот так:
setPosts([...posts].sort((a,b)=>{
  a[sort].localCompare(b[sort])
}))
