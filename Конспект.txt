Полное видео тут: https://www.youtube.com/watch?v=GNrdg3PzpJQ&ab_channel=UlbiTV

Как реакт работает.
Реакт это не библиотека для вэб приложений, он может работать сам по себе
За отображанеие в браузере отвечает библиотека react dom

Приложение реакт это набор связанных компонентов.
В начале работы реакт создаёт "дерево реакт элементов"(более лёгкая чем dom дерево), которое потом трансформируется в dom дерево
Как только в реакт компонентах происходит изменения, до реакт создаёт другое дерево с изменёнными 
компонентами и сравнивает его с предыдущим деревом реакт элементов (там где узлы имеют старые значения). Эта стадия называется "Согласование"
Согласование происходит как в браузере так и в других средах, где будет запущен реакт.

После того, как различия были выявлены в результате согласования - происходит фаза рендеринга(отрисовки) (за эту фазу отвечает react dom, react native)
причём у отрисовки есть приоритетность, поэтому некоторые элементы отображаются быстрее.

В компоненте - классе когда в onClick указываешь стерлочную функцию то она сработает не так как
мы ожидаем, особенно, если ты не оперируешь переменными состояния.
Проще говоря, если рендеринг зависит от переменных, то они должны быть состояними, если ты просто
их укажешь как переменные или свойства объекта реакт, то сам реакт их не отрисует.

Когда вешаешь на тэг (input,button ...) событие - это событие может принимать в аргумент 
объект события (event) у этого объекта есть поле target - этот объект и есть node узел, где сработало это событие, уже у этого объекта можно взять value, className ...
Выглядит это так : onChange={(event)=>{setValue(event.target.value)}}

 Файлы компонентов нужно нахывать также как и сам компонент и ВСЕГДА  с большой буквы.
 
 Состояния компонентов - независимы.
 Т.е. если ты создашь элемент counter и вызовёшь его несколько раз, то значения всех counter'ов будут различны.

---Классовые компокнетнты (classCounter)
В реакт классах нельзя напрямую изменять состояния, т.к. реакт компонент НЕ УВИДИТ изменений.
Для измнения состояния в классах нужно использовать метод setState куда нужно будет вписывать изменённые поля state
например this.setState({count: this.state.count+1});
Также внутри класса нужно обрщаться к переменным и функциям через this
Также в классовых компонентах в методах - контекст теряется, поэтому в конструкторе нужно их бидить
Например так: constructor(props){super(props); this.someFunc = this.someFunc.bind(this)}
до30 минуты

---Массив хуков состояние 
Он записывается следующим образом :
const [posts,setposts] = useState([
	{},
	{},
	{},
])
Кстати, для преобразования массива данных в массив постов - используй .map , а не forEach, как ты это любишь делать
с map всё намного лучше читается {post.map(post=><Post post=post />))

---ключи списков
key - лучше указывать не через index массива, а через отдельное свойство отведённое специально для этого.
post = {id = 1, desc = "some description" , title = "some title" } - видишь id? Вот его и нужно пихать в key
index - использовать нежелательно, т.к. index может измениться при удалении или смещении элементов, а ключ - всегда
должен быть постоянным.
Благодоря ключам - отрисовываться будут только те элементы списка, которые изменились, а не весь список.

---инлайновые стили прописываются следующим образом
<h1 style = {{textAlign: "center"}}>Список задач</h1>

---Вместо props можно передавать конкретные переменные
const PostList = ({posts,title})=>{} - этот компонент принимает НЕ PROPS А POSTS. эта переменная сразу извлекается
из props, и дальше её можно использовать без указания props. Т.е. не props.posts а просто posts.
Если же прописать нужно выделить несколько аргументов и остально положить в props, то используют следующую запись
const Component = ({someArg1, someArg2, ... props}) {}. Теперь в props будет всё кроме someArg1 и someArg2

---Чтобы аттрибуты компонента попадали в сами тэги нужно это указать напрямую
<button {...props}> </button>
Это очень поможет при аттрибутах checked и disabled

---Модульное добавление стилей
Ты можешь создать файл имяКомпонента.module.css
В нём указать селектор(класс) и свойства к нему, а затем, в нужный компонент
ты можешь это импортировать командой
import classes from './имяКомпонента.module.css'
и в нужно строке вызвать аргумент класса - <button className={classes.myBtn}>
смотри подробнее в src-components-UI-button-MyButton.jsx
Такой подход генерирует уникальные названия классов, что позволяет не прибегать к БЭМ.
Например, ты вызвал класс myBtn в компоненте MyButton, значит после сборки класс будет называться - MyButton_myBtn__B8hLn
Это приводит к изоляции стилей и БЭМ становится ненужным

---PROPS.CHILDREN
Данный пропс позволяет закрывающим тэгам получать информацию заключённую между ними. Т.е.
<MyButton> some button text </MyButton> 
Чтобы отобразить some button text - нужно использовать props.children

---ХУКИ
